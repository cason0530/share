安卓recovery启动到升级一目了然

recovery源码的入口位置为:bootable/recovery/recovery.cpp文件

int main(int argc, char **argv)
{
    一、打印启动recovery的时间
    printf("Starting recovery on %s", ctime(&start));
	
	二、填充fstab结构体
	load_volume_table(){
		解析/etc/recovery.fstab配置文件，填充fstab结构体
		fstab = fs_mgr_read_fstab("/etc/recovery.fstab");

		在fstab结构体中增加/tmp分区
		ret = fs_mgr_add_entry(fstab, "/tmp", "ramdisk", "ramdisk", 0);
	}
	
	二、挂载cache分区
	ensure_path_mounted(LAST_LOG_FILE){
		这里是在fstab结构体中找到挂载点为/cache的fstab_recs
		Volume* v = volume_for_path(path);

		ramdisk类型的分区是一直挂载的。
		if (strcmp(v->fs_type, "ramdisk") == 0) {
			return 0;
		}

		当前分区是否被挂载
		const MountedVolume* mv = find_mounted_volume_by_mount_point(v->mount_point);
		if (mv) {
			//已经被挂载
			return 0;
		}

		具体的挂载过程
		mkdir(v->mount_point, 0755);
		if (strcmp(v->fs_type, "ext4") == 0 || strcmp(v->fs_type, "vfat") == 0) {
			// ext4和vfat类型的分区调用mount函数进行挂载，挂载成功返回0，失败返回-1
			result = mount(v->blk_device, v->mount_point, v->fs_type, MS_NOATIME | MS_NODEV | MS_NODIRATIME, "");
		}
	}
	
	三、获取Recovery命令参数
	get_args(&argc, &argv){
		首先从MISC分区中读取BCB数据块到boot变量中，可能存在为空的情况。
		get_bootloader_message(&boot);
		stage = strndup(boot.stage, sizeof(boot.stage));
		
		从/cache/recovery/command获取参数，一般常用的ota升级做法。
		if (*argc < 1) {
			FILE *fp = fopen_path(COMMAND_FILE, "r");
			if (fp != NULL) {        
				*argv = (char **) malloc(sizeof(char *) * MAX_ARGS);
				for (*argc = 1; *argc < MAX_ARGS; ++*argc) {
					if (!fgets(buf, sizeof(buf), fp)) break;
				}
				check_and_fclose(fp, COMMAND_FILE);
			}
		}
		
		将从/cache/recovery/command获取的参数写入到misc分区
			...省略
	}	
	
	四、分析recovery命令
	while ((arg = getopt_long(argc, argv, "", OPTIONS, NULL)) != -1) {
        switch(arg) {
        case 's': send_intent = optarg; break;
        case 'u': update_package = optarg; break;
        case 'w': wipe_data = wipe_cache = 1; break;
        case 'c': wipe_cache = 1; break;
        case 't': show_text = 1; break;
        case 'x': just_exit = true; break;
        case 'l': locale = optarg; break;
        case 'p': shutdown_after = true; break;
        case '?':
            LOGE("Invalid command argument\n");
            continue;
        }
    }
	五、升级install_package过程
	if (update_package != NULL) {
		status = install_package(update_package, &wipe_cache, TEMPORARY_INSTALL_FILE){
			卸载除了/tmp和/cache的其他分区
			setup_install_mounts()
			
			ota升级的真正实现,这里去除掉跟UI显示相关的逻辑
			result = really_install_package(path, wipe_cache){
				确保zip包所在的目录是挂载的
				if (ensure_path_mounted(path) != 0)
				加载公钥源文件,根据公钥对zip包进行校验
				Certificate* loadedKeys = load_keys(PUBLIC_KEYS_FILE, &numKeys);
				err = verify_file(path, loadedKeys, numKeys);
				打开升级包，并将相关的信息拷贝到一个临时的ZipArchinve变量中。这一步并未对我们的update.zip包解压。
				err = mzOpenZipArchive(path, &zip);
				真正fota升级的过程
				return try_update_binary(path, &zip, wipe_cache);
			}
		}
	}
}
http://blog.csdn.net/wzy_1988/article/details/46862247







应用程序角度讲：
1、在单核计算机里，有一个资源是无法被多个程序并行使用的：cpu。
没有操作系统的情况下，一个程序一直独占着全都cpu。
如果要有两个任务来共享同一个CPU，程序员就需要仔细地为程序安排好运行计划--某时刻cpu和由程序A来独享，下一时刻cpu由程序B来独享
而这种安排计划后来成为OS的核心组件，被单独名命为“scheduler”，即“调度器”，它关心的只是怎样把单个cpu的运行拆分成一段一段的“运行片”，轮流分给不同的程序去使用，而在宏观上，因为分配切换的速度极快，就制造出多程序并行在一个cpu上的假象。
2、在单核计算机里，有一个资源可以被多个程序共用，然而会引出麻烦：内存。
在一个只有调度器，没有内存管理组件的操作系统上，程序员需要手工为每个程序安排运行的空间 -- 程序A使用物理地址0x00-0xff,程序B使用物理地址0x100-0x1ff，等等。
然而这样做有个很大的问题：每个程序都要协调商量好怎样使用同一个内存上的不同空间，软件系统和硬件系统千差万别，使这种定制的方案没有可行性。
为了解决这个麻烦，计算机系统引入了“虚拟地址”的概念，从三方面入手来做：
2.1、硬件上，CPU增加了一个专门的模块叫MMU，负责转换虚拟地址和物理地址。
2.2、操作系统上，操作系统增加了另一个核心组件：memory management，即内存管理模块，它管理物理内存、虚拟内存相关的一系列事务。
2.3、应用程序上，发明了一个叫做【进程】的模型，（注意）每个进程都用【完全一样的】虚拟地址空间，然而经由操作系统和硬件MMU协作，映射到不同的物理地址空间上。不同的【进程】，都有各自独立的物理内存空间，不用一些特殊手段，是无法访问别的进程的物理内存的。
3、现在，不同的应用程序，可以不关心底层的物理内存分配，也不关心CPU的协调共享了。然而还有一个问题存在：有一些程序，想要共享CPU，【并且还要共享同样的物理内存】，这时候，一个叫【线程】的模型就出现了，它们被包裹在进程里面，在调度器的管理下共享CPu，拥有同样的虚拟地址空间，同时也共享同一个物理地址空间，然而，它们无法越过包裹自己的进程，去访问别一个进程的物理地址空间。
4、进程之间怎样共享同一个物理地址空间呢？不同的系统方法各异，符合posix规范的操作系统都提供了一个接口，叫mmap，可以把一个物理地址空间映射到不同的进程中，由不同的进程来共享。
5、PS：在有的操作系统里，进程不是调度单位（即不能被调度器使用），线程是最基本的调度单位，调度器只调度线程，不调度进程，比如VxWorks

定义：
1. 进程：程序的一次执行
2. 线程：CPU的基本调度单位

根源：
任务事物的出现都是为了解决问题的。
没有操作系统的情况下，一个程序会独占着cpu，为了让多个任务共享一个CPU,就产生的进程的概念，但是有其独立的物理内存空间。
为了解决即可以共享一个cpu,又可以共享相同的物理内存空间，所以就产生了线程

疑惑：


总结：
一个程序至少有一个进程,一个进程至少有一个线程
线程执行开销小，但不利于资源的管理和保护，而进程正相反

